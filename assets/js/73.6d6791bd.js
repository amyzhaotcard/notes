(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{448:function(e,v,r){"use strict";r.r(v);var n=r(26),_=Object(n.a)({},(function(){var e=this,v=e.$createElement,r=e._self._c||v;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"虚拟-dom"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#虚拟-dom"}},[e._v("#")]),e._v(" 虚拟 DOM")]),e._v(" "),r("h2",{attrs:{id:"什么是虚拟-dom"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是虚拟-dom"}},[e._v("#")]),e._v(" 什么是虚拟 DOM")]),e._v(" "),r("p",[e._v("虚拟 DOM 是一层对真实 DOM 的抽象，以 JavaScript 对象 (VNode 节点) 作为基础的树，用对象的属性来描述节点，最终可以通过一系列操作使这棵树映射到真实环境上")]),e._v(" "),r("p",[e._v("在 Javascript 对象中，虚拟 DOM 表现为一个 Object 对象。并且最少包含标签名 (tag)、属性 (attrs) 和子元素对象 (children) 三个属性，不同框架对这三个属性的名命可能会有差别")]),e._v(" "),r("h2",{attrs:{id:"为什么需要虚拟-dom"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要虚拟-dom"}},[e._v("#")]),e._v(" 为什么需要虚拟 DOM")]),e._v(" "),r("ul",[r("li",[e._v("DOM 是很慢的，其元素非常庞大，页面的性能问题，大部分都是由 DOM 操作引起的，操作 DOM 的代价是昂贵的，频繁操作会出现页面卡顿，影响用户的体验")]),e._v(" "),r("li",[e._v("虚拟 DOM 不会立即操作 DOM，而是将更新的 diff 内容保存到本地的一个 js 对象中，最终将这个 js 对象一次性 attach 到 DOM 树上，避免大量的无谓计算")]),e._v(" "),r("li",[e._v("很多人认为虚拟 DOM 最大的优势是 diff 算法，减少 JavaScript 操作真实 DOM 的带来的性能消耗。虽然这一个虚拟 DOM 带来的一个优势，但并不是全部。虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种 GUI")])]),e._v(" "),r("h2",{attrs:{id:"虚拟-dom-有什么坏处"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#虚拟-dom-有什么坏处"}},[e._v("#")]),e._v(" 虚拟 DOM 有什么坏处？")]),e._v(" "),r("ul",[r("li",[e._v("无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。")]),e._v(" "),r("li",[e._v("需要额外的创建函数，如 createElement 或 h，但可以通过 JSX 或者 vue-loader 来简化成 XML 写法。但是这么做会依赖打包工具。")])]),e._v(" "),r("h2",{attrs:{id:"vue-对-虚拟-dom-的优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue-对-虚拟-dom-的优化"}},[e._v("#")]),e._v(" vue 对 虚拟 dom 的优化")]),e._v(" "),r("ul",[r("li",[e._v("nextTick()")]),e._v(" "),r("li",[e._v("patch 算法\n当新的 VNode 与旧的 oldVNode 都是元素节点并且都包含子节点时，那么这两个节点的 VNode 实例上的 children 属性就是所包含的子节点数组。我们把新的 VNode 上的子节点数组记为 newChildren，把旧的 oldVNode 上的子节点数组记为 oldChildren。")])]),e._v(" "),r("p",[e._v("同样是有四种情况：")]),e._v(" "),r("ul",[r("li",[e._v("创建子节点：如果 newChildren 里面的某个子节点在 oldChildren 里找不到与之相同的子节点，那么说明 newChildren 里面的这个子节点是之前没有的，是需要此次新增的节点，那么就创建子节点。")]),e._v(" "),r("li",[e._v("删除子节点：如果把 newChildren 里面的每一个子节点都循环完毕后，发现在 oldChildren 还有未处理的子节点，那就说明这些未处理的子节点是需要被废弃的，那么就将这些节点删除。")]),e._v(" "),r("li",[e._v("移动子节点：如果 newChildren 里面的某个子节点在 oldChildren 里找到了与之相同的子节点，但是所处的位置不同，这说明此次变化需要调整该子节点的位置，那就以 newChildren 里子节点的位置为基准，调整 oldChildren 里该节点的位置，使之与在 newChildren 里的位置相同。")]),e._v(" "),r("li",[e._v("更新节点：如果 newChildren 里面的某个子节点在 oldChildren 里找到了与之相同的子节点，并且所处的位置也相同，那么就更新 oldChildren 里该节点，使之与 newChildren 里的该节点相同。")])]),e._v(" "),r("p",[e._v("外层循环新节点的 children 数组，内层循环旧节点的 children 数组，每循环外层的新节点的 children 数组中的一个子节点，就去内层老节点的 children 数组中去找有没有相同的节点，再根据不同的情况去做操作。当包含的子节点数量过多时，这样循环算法的时间复杂度就会变的很大，不利于性能提升。")]),e._v(" "),r("p",[e._v("优化：")]),e._v(" "),r("ul",[r("li",[e._v("先把 newChildren 数组里的所有"),r("strong",[e._v("未处理")]),e._v("子节点的"),r("strong",[e._v("第一个子节点")]),e._v("和 oldChildren 数组里所有"),r("strong",[e._v("未处理")]),e._v("子节点的"),r("strong",[e._v("第一个子节点")]),e._v("做比对，如果相同，那就直接进入更新节点的操作；")]),e._v(" "),r("li",[e._v("如果不同，再把 newChildren 数组里所有"),r("strong",[e._v("未处理")]),e._v("子节点的"),r("strong",[e._v("最后一个子节点")]),e._v("和 oldChildren 数组里所有"),r("strong",[e._v("未处")]),e._v("理子节点的"),r("strong",[e._v("最后一个子节点")]),e._v("做比对，如果相同，那就直接进入更新节点的操作；")]),e._v(" "),r("li",[e._v("如果不同，再把 newChildren 数组里所有"),r("strong",[e._v("未处理")]),e._v("子节点的"),r("strong",[e._v("最后一个子节点")]),e._v("和 oldChildren 数组里所有"),r("strong",[e._v("未处理")]),e._v("子节点的"),r("strong",[e._v("第一个子节点")]),e._v("做比对，如果相同，那就直接进入更新节点的操作，更新完后再将 oldChildren 数组里的该节点移动到与 newChildren 数组里节点相同的位置；")]),e._v(" "),r("li",[e._v("如果不同，再把 newChildren 数组里所有"),r("strong",[e._v("未处理")]),e._v("子节点的"),r("strong",[e._v("第一个子节点")]),e._v("和 oldChildren 数组里所有"),r("strong",[e._v("未处理")]),e._v("子节点的"),r("strong",[e._v("最后一个子节点")]),e._v("做比对，如果相同，那就直接进入更新节点的操作，更新完后再将 oldChildren 数组里的该节点移动到与 newChildren 数组里节点相同的位置；")]),e._v(" "),r("li",[e._v("最后四种情况都试完如果还不同，那就按照之前循环的方式来查找节点。")])])])}),[],!1,null,null,null);v.default=_.exports}}]);