(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{380:function(t,a,_){t.exports=_.p+"assets/img/qiankun.497f9676.png"},502:function(t,a,_){"use strict";_.r(a);var e=_(26),v=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"标准签-微前端-qiankun"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#标准签-微前端-qiankun"}},[t._v("#")]),t._v(" 标准签-微前端（qiankun）")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://www.notion.so/qiankun-1110c4ff6f5244709dcc18b9f289c923",target:"_blank",rel:"noopener noreferrer"}},[t._v("标准签对接 qiankun"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://mp.weixin.qq.com/s/EG0ybc5hLgUzHoNvIPapFw",target:"_blank",rel:"noopener noreferrer"}},[t._v("qiankun 原理简述"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"什么是微前端"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是微前端"}},[t._v("#")]),t._v(" 什么是微前端")]),t._v(" "),e("blockquote",[e("p",[t._v("微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。")])]),t._v(" "),e("img",{attrs:{src:_(380),width:"800"}}),t._v(" "),e("h2",{attrs:{id:"微前端的特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#微前端的特点"}},[t._v("#")]),t._v(" 微前端的特点")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("技术栈无关")]),t._v("： 主框架不限制接入应用的技术栈，微应用具备完全自主权")]),t._v(" "),e("li",[e("strong",[t._v("独立开发、独立部署")]),t._v("： 微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新")]),t._v(" "),e("li",[e("strong",[t._v("增量升级")]),t._v("： 在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略")]),t._v(" "),e("li",[e("strong",[t._v("独立运行时")]),t._v("： 每个微应用之间状态隔离，运行时状态不共享")])]),t._v(" "),e("h2",{attrs:{id:"微前端的缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#微前端的缺点"}},[t._v("#")]),t._v(" 微前端的缺点")]),t._v(" "),e("ul",[e("li",[t._v("需要在开发中运行许多不同的应用程序以测试完成的体验")]),t._v(" "),e("li",[t._v("跟踪和调试问题需要跨全部系统")])]),t._v(" "),e("h2",{attrs:{id:"为什么不用-iframe-实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么不用-iframe-实现"}},[t._v("#")]),t._v(" 为什么不用 iframe 实现")]),t._v(" "),e("ul",[e("li",[t._v("url 不同步。浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用。")]),t._v(" "),e("li",[t._v("UI 不同步，DOM 结构不共享。想象一下屏幕右下角 1/4 的 iframe 里来一个带遮罩层的弹框，同时我们要求这个弹框要浏览器居中显示，还要浏览器 resize 时自动居中..")]),t._v(" "),e("li",[t._v("全局上下文完全隔离，内存变量不共享。iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果。")]),t._v(" "),e("li",[t._v("慢。每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程。")])]),t._v(" "),e("h2",{attrs:{id:"实现原理-应用隔离"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现原理-应用隔离"}},[t._v("#")]),t._v(" 实现原理 - 应用隔离")]),t._v(" "),e("p",[t._v("基于"),e("code",[t._v("window.Proxy")]),t._v(" 实现 "),e("code",[t._v("genSandbox")])]),t._v(" "),e("ul",[e("li",[t._v("LegacySandbox")]),t._v(" "),e("li",[t._v("多实例沙箱 - ProxySandbox （使用 window.proxy（pu，热，ke，sei））")]),t._v(" "),e("li",[t._v("IE 下使用 SnapshotSandbox （diff）")])]),t._v(" "),e("h2",{attrs:{id:"实现原理-应用通讯"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现原理-应用通讯"}},[t._v("#")]),t._v(" 实现原理 - 应用通讯")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://juejin.cn/post/6844904151231496200",target:"_blank",rel:"noopener noreferrer"}},[t._v("基于 qiankun 的微前端最佳实践（图文并茂） - 应用间通信篇"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("code",[t._v("qiankun")]),t._v(" 内部提供了 "),e("code",[t._v("initGlobalState")]),t._v(" 方法用于注册 "),e("code",[t._v("MicroAppStateActions")]),t._v(" 实例用于通信，该实例有三个方法，分别是：")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("setGlobalState")]),t._v("：设置 "),e("code",[t._v("globalState")]),t._v(" - 设置新的值时，内部将执行 "),e("code",[t._v("浅检查")]),t._v("，如果检查到 "),e("code",[t._v("globalState")]),t._v(" 发生改变则触发通知，通知到所有的 "),e("code",[t._v("观察者")]),t._v(" 函数。")]),t._v(" "),e("li",[e("code",[t._v("onGlobalStateChange")]),t._v("：注册 "),e("code",[t._v("观察者")]),t._v(" 函数 - 响应 "),e("code",[t._v("globalState")]),t._v(" 变化，在 "),e("code",[t._v("globalState")]),t._v(" 发生改变时触发该 "),e("code",[t._v("观察者")]),t._v(" 函数。")]),t._v(" "),e("li",[e("code",[t._v("offGlobalStateChange")]),t._v("：取消 "),e("code",[t._v("观察者")]),t._v(" 函数 - 该实例不再响应 "),e("code",[t._v("globalState")]),t._v(" 变化。")])]),t._v(" "),e("h2",{attrs:{id:"实现原理-样式隔离"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现原理-样式隔离"}},[t._v("#")]),t._v(" 实现原理 - 样式隔离")]),t._v(" "),e("ul",[e("li",[t._v("runtime css transformer（严格模式：Shadow DOM）")])]),t._v(" "),e("h2",{attrs:{id:"实现原理-js-隔离"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现原理-js-隔离"}},[t._v("#")]),t._v(" 实现原理 - js 隔离")]),t._v(" "),e("p",[t._v("qiankun 的隔离方式有两种：")]),t._v(" "),e("ul",[e("li",[t._v("基于 proxy 对全局 window 生成一个代理对象")]),t._v(" "),e("li",[t._v("通过快照沙箱在沙箱挂载和卸载的时候记录快照，在应用切换的时候依据快照恢复环境。")])]),t._v(" "),e("p",[t._v("qiankun 则是根据当前环境是否存在 proxy 来判断他的隔离方式。")])])}),[],!1,null,null,null);a.default=v.exports}}]);