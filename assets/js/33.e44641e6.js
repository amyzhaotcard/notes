(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{401:function(t,a,e){"use strict";e.r(a);var r=e(26),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"手写动画"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#手写动画"}},[t._v("#")]),t._v(" 手写动画")]),t._v(" "),e("h4",{attrs:{id:"如果需要手动写动画-你认为最小时间间隔是多久-为什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如果需要手动写动画-你认为最小时间间隔是多久-为什么"}},[t._v("#")]),t._v(" 如果需要手动写动画，你认为最小时间间隔是多久，为什么？")]),t._v(" "),e("p",[t._v("多数显示器默认频率是 60Hz，即 1 秒刷新 60 次，所以理论上最小间隔为 1/60＊1000ms ＝ 16.7ms")]),t._v(" "),e("h4",{attrs:{id:"手写动画一般用到的-api-是什么合适"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#手写动画一般用到的-api-是什么合适"}},[t._v("#")]),t._v(" 手写动画一般用到的 api 是什么合适?")]),t._v(" "),e("ul",[e("li",[t._v("window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行")]),t._v(" "),e("li",[t._v("若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用 window.requestAnimationFrame()")]),t._v(" "),e("li",[t._v("请确保总是使用第一个参数(或其它获得当前时间的方法)计算每次调用之间的时间间隔，否则动画在高刷新率的屏幕中会运行得更快。")]),t._v(" "),e("li",[t._v("window.requestAnimationFrame(callback);")])])])}),[],!1,null,null,null);a.default=s.exports}}]);