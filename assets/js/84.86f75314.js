(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{460:function(e,r,t){"use strict";t.r(r);var v=t(26),i=Object(v.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"双向绑定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双向绑定"}},[e._v("#")]),e._v(" 双向绑定")]),e._v(" "),t("p",[e._v("Vue2.0 defineProperty")]),e._v(" "),t("ul",[t("li",[e._v("实现一个数据监听器 Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者")]),e._v(" "),t("li",[e._v("实现一个指令解析器 Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数")]),e._v(" "),t("li",[e._v("实现一个 Watcher，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图")]),e._v(" "),t("li",[e._v("mvvm 入口函数，整合以上三者")])]),e._v(" "),t("h2",{attrs:{id:"defineproperty-实现数据监听-简述它的优势与不足"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#defineproperty-实现数据监听-简述它的优势与不足"}},[e._v("#")]),e._v(" defineProperty 实现数据监听，简述它的优势与不足")]),e._v(" "),t("p",[e._v("优势：更专注于数据，而非视图；相较 proxy 兼容性较好")]),e._v(" "),t("p",[e._v("不足：无法检测到对象属性的新增或删除；无法监听数组变化。\n（ defineProperty 的兼容性其实是不足之处，vue 的早期大家对于在项目中是否使用 vue 的一个考虑就是 ie 兼容问题。）")]),e._v(" "),t("h2",{attrs:{id:"defineproperty-无法检测到对象属性的新增或删除和无法监听数组变化-vue-是怎么做的去补足它呢"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#defineproperty-无法检测到对象属性的新增或删除和无法监听数组变化-vue-是怎么做的去补足它呢"}},[e._v("#")]),e._v(" defineProperty 无法检测到对象属性的新增或删除和无法监听数组变化，vue 是怎么做的去补足它呢？")]),e._v(" "),t("ul",[t("li",[e._v("数组：重写了一些数组的方法，重写了数组 slice splice pop shift unshift 等")]),e._v(" "),t("li",[e._v("对象：this.$set")])]),e._v(" "),t("h2",{attrs:{id:"vue3-为什么使用-proxy"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue3-为什么使用-proxy"}},[e._v("#")]),e._v(" vue3 为什么使用 proxy")]),e._v(" "),t("ul",[t("li",[e._v("可以直接监听对象而不是属性")]),e._v(" "),t("li",[e._v("可以直接监听数组变化")]),e._v(" "),t("li",[e._v("能监测到新添加的属性")]),e._v(" "),t("li",[e._v("有很多拦截方法")]),e._v(" "),t("li",[e._v("返回的是一个新对象")]),e._v(" "),t("li",[e._v("proxy 直接对一个对象做响应式，无论这个对象有多深，只需要执行一次就好。")])])])}),[],!1,null,null,null);r.default=i.exports}}]);