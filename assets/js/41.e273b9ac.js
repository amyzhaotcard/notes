(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{411:function(r,e,t){"use strict";t.r(e);var a=t(26),n=Object(a.a)({},(function(){var r=this,e=r.$createElement,t=r._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("h1",{attrs:{id:"generator"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#generator"}},[r._v("#")]),r._v(" generator")]),r._v(" "),t("p",[r._v("async / await 是 generator 的语法糖")]),r._v(" "),t("h2",{attrs:{id:"generator-函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#generator-函数"}},[r._v("#")]),r._v(" Generator 函数")]),r._v(" "),t("p",[r._v("Generator 函数是协程在 ES6 的实现，最大特点就是可以"),t("strong",[r._v("交出函数的执行权")]),r._v("（即暂停执行）。")]),r._v(" "),t("p",[r._v("Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。")]),r._v(" "),t("p",[r._v("形式上，Generator 函数是一个普通函数，但是有两个特征：")]),r._v(" "),t("ul",[t("li",[r._v("function 关键字与函数名之间有一个星号")]),r._v(" "),t("li",[r._v("函数体内部使用 yield 表达式，定义不同的内部状态")])]),r._v(" "),t("h2",{attrs:{id:"异步解决方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异步解决方案"}},[r._v("#")]),r._v(" 异步解决方案")]),r._v(" "),t("ul",[t("li",[r._v("回调函数")]),r._v(" "),t("li",[r._v("Promise 对象")]),r._v(" "),t("li",[r._v("generator 函数")]),r._v(" "),t("li",[r._v("async/await")])]),r._v(" "),t("p",[r._v("ES6 诞生之前只有以下几种：")]),r._v(" "),t("ul",[t("li",[r._v("回调函数")]),r._v(" "),t("li",[r._v("事件监听")]),r._v(" "),t("li",[r._v("发布/订阅")]),r._v(" "),t("li",[r._v("Promise 对象")])]),r._v(" "),t("h3",{attrs:{id:"promise、generator、async-await-比较"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise、generator、async-await-比较"}},[r._v("#")]),r._v(" promise、Generator、async/await 比较")]),r._v(" "),t("ul",[t("li",[r._v("promise 和 async/await 是专门用于处理异步操作的")]),r._v(" "),t("li",[r._v("Generator 并不是为异步而设计出来的，它还有其他功能（对象迭代、控制输出、部署 Interator 接口...）")]),r._v(" "),t("li",[r._v("promise 编写代码相比 Generator、async 更为复杂化，且可读性也稍差")]),r._v(" "),t("li",[r._v("Generator、async 需要与 promise 对象搭配处理异步情况")]),r._v(" "),t("li",[r._v("async 实质是 Generator 的语法糖，相当于会自动执行 Generator 函数")]),r._v(" "),t("li",[r._v("async 使用上更为简洁，将异步代码以同步的形式进行编写，是处理异步编程的最终方案")])]),r._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[r._v("TIP")]),r._v(" "),t("p",[r._v("Promise 的写法只是回调函数的改进，使用 then 方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意")])]),r._v(" "),t("p",[t("a",{attrs:{href:"http://www.alloyteam.com/2016/02/generators-in-depth/",target:"_blank",rel:"noopener noreferrer"}},[r._v("深入理解 generator"),t("OutboundLink")],1)]),r._v(" "),t("p",[t("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/generator-async",target:"_blank",rel:"noopener noreferrer"}},[r._v("Generator 函数的异步应用"),t("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=n.exports}}]);