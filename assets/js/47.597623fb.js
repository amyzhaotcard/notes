(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{417:function(t,n,o){"use strict";o.r(n);var e=o(26),a=Object(e.a)({},(function(){var t=this,n=t.$createElement,o=t._self._c||n;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h1",{attrs:{id:"react-的生命周期"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#react-的生命周期"}},[t._v("#")]),t._v(" react 的生命周期")]),t._v(" "),o("ul",[o("li",[o("p",[t._v("初始化阶段：")]),t._v(" "),o("p",[t._v("componentWillMount：实例挂载之前")]),t._v(" "),o("p",[t._v("Render：渲染组件")]),t._v(" "),o("p",[t._v("componentDidMount：实例挂载完成。一般在这个函数中与后台进行初始化数据交互")])]),t._v(" "),o("li",[o("p",[t._v("运行阶段")]),t._v(" "),o("p",[t._v("componentWillReceiveProps：父组件改变时调用")]),t._v(" "),o("p",[t._v("shouldComponentUpdate：主要是用来手动阻止组件渲染，一般在这个函数中做组件的"),o("strong",[t._v("性能优化")])]),t._v(" "),o("p",[t._v("componentWillUpdate：组件数据更新前调用")]),t._v(" "),o("p",[t._v("componentDidUpdate：组件数据更新完成时调用")])]),t._v(" "),o("li",[o("p",[t._v("销毁阶段")]),t._v(" "),o("p",[t._v("componentUnmount：销毁阶段。一般用来销毁不用的变量或者是解除无用定时器以及解绑无用事件，防止内存泄漏问题")])])]),t._v(" "),o("h4",{attrs:{id:"运行阶段生命周期调用顺序"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#运行阶段生命周期调用顺序"}},[t._v("#")]),t._v(" 运行阶段生命周期调用顺序：")]),t._v(" "),o("p",[t._v("componentWillReceiveProps–>shouldComponentUpdate --\x3e componentWillupdate --\x3e componentDidUpdate")]),t._v(" "),o("h3",{attrs:{id:"为什么要在-componentdidmount-中发送-ajax-请求"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#为什么要在-componentdidmount-中发送-ajax-请求"}},[t._v("#")]),t._v(" 为什么要在 componentDidMount 中发送 ajax 请求")]),t._v(" "),o("ul",[o("li",[t._v("componentDidmount 是在组件完全挂载后才会执行，在此方法中调用 setState 会触发重新渲染，最重要的是，这是官方推荐的；")]),t._v(" "),o("li",[t._v("constructor 调用是在一开始，组件未挂载，所以不能用；")]),t._v(" "),o("li",[t._v("componentWillMount 调用在 constructor 后，在这里的代码调用 setState 不会出发重新渲染，并且在 componentWillMount 里进行网络请求会阻碍组件的渲染，所以不用")])])])}),[],!1,null,null,null);n.default=a.exports}}]);